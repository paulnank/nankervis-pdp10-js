; PDP-10 Macro code for booting an emulated DECsystem-10 (PDP-10 KI10) ; See https://skn.noip.me/pdp10/pdp10.html for more information;; boot loader code;; .tty lc width 132; .r macro; *boot=boot; .load boot; .save boot.sav; .r convrt; FILE: boot.sav; type boot.a10a=1b=2c=3d=4e=5f=6p=17buffer=2000nosymloc 37000start:    cono    apr,200000  ;reset everything    cono    pi,10400    jfcl    0,0    movei   p,stack     ;initialize stack    movei   b,banner    pushj   p,print     ;print bannergetcmd:    movei   b,prompt    pushj   p,print     ;print prompt    movei   e,0         ;zero character count    move    d,[<point 7,buffer>]  ;initialize buffer pointergetch:    conso   tty,40      ;ttyi idle    jrst    .-1         ;wait for input    datai   tty,c       ;get character    andi    c,177       ;make into 7 bit    cain    c,177    jrst    rubout      ;handle rubout    cail    c,40    jrst    echo        ;if space or above echo it    cain    c,10    jrst    rubout      ;handle backspace    cain    c,15    jrst    cmd         ;if enter process command    jrst    getch       ;ignore non-printablerubout:    jumpe   e,getch     ;ignore if empty buffer    movei   b,del    pushj   p,print     ;rubout last character    subi    e,1         ;decrement character count    move    d,[<point 7,buffer>]  ;reset buffer pointer    move    c,e    sojl    c,getch    ibp     d           ;move pointer past last character    jrst    .-2echo:    consz   tty,20      ;ttyo idle?    jrst    .-1         ;loop until idle    datao   tty,c       ;echo character    caile   c,140       ;skip if not l.c    trz     c,40        ;make u.c.    idpb    c,d         ;put character in buffer    addi    e,1         ;increment character count    jrst getchcmd:    movei   c,0    idpb    c,d         ;null terminate input string    movei   b,eol    pushj   p,print     ;print end of line    move    d,[<point 7,buffer>]    ildb    c,d    jumpe   c,getcmd    ;null - ignore blank line    cain    c,40    jrst    .-3         ;skip leading space    movei   a,0         ;initialize command indexnxtcmd:    move    e,cmdtbl(a) ;get pointer to command string    jumpe   e,unkcmd    ;end of command table    move    f,d         ;copy ptr to user input    ldb     c,fnxtchr:    jumpe   c,gotcmd    ;end of user input?    cain    c,40    jrst    gotcmd      ;space - end of command name    ildb    b,e    came    b,c    jrst    nomtch    ildb    c,f         ;check next character    jrst    nxtchrnomtch:    addi    a,1    jrst    nxtcmd      ;no match so move onto next possible commandgotcmd:    jrst    @cmdjmp(a)  ;execute commandunkcmd:    movei   b,unkmsg    pushj   p,print     ;dunno that command    jrst    getcmdhelp:    movei   b,hlpmsg    pushj   p,print     ;print some help blurb    jrst    getcmdprint:    hrli    b,(<point 7,,>) ;make byte pointer for stringprnext:    ildb    c,b         ;get character    jumpe   c,prdone    ;exit if done    consz   tty,20      ;ttyo idle?    jrst    .-1         ;loop until idle    datao   tty,c       ;send character    jrst    prnextprdone:    popj    p,         ;return    ildb    c,fboot:    jumpe   c,noboot    ;no device?    cain    c,40    jrst    .-3         ;skip over spaces    movei   a,0         ;initialize device indexnxtdev:    move    e,devtbl(a) ;get pointer to device string    jumpe   e,noboot    ;end of device table    move    d,f         ;copy ptr to device name    ldb     c,dnxtdch:    ildb    b,e    jumpe   b,gotdev    ;end of device name?    came    b,c    jrst    notdev    ildb    c,d         ;check next user character    jrst    nxtdchnotdev:    addi    a,1    jrst    nxtdev      ;no match so move to next devicegotdev:    movei   b,0         ;initialize unit numbernxtdgt:    caig    c,"9"    caige   c,"0"    jrst    endunt    subi    c,"0"    imuli   b,12    add     b,c         ;add digit to unit number    ildb    c,d    jrst    nxtdgtendunt:    jumpe   c,doboot    ;if end of input string do boot    cain    c,40        ;if not a space then weird input    jrst    dobootnoboot:    movei   b,badboo    pushj   p,print     ;something wrong with boot device name    jrst    getcmddoboot:    andi    b,7         ;unit is 3 bit    jrst    @boojmp(a)  ;execute boot with unit # in bldaddr=777000dpaboo:    lsh     b,36        ;at bit 3    cono    dpc,173710  ;clear controller status    hrlzi   e,400000    ;command seek(4)    or      e,b         ;insert unit    datao   dpc,e       ;execute    consz   dpc,20    jrst    .-1         ;wait for busy clear    conso   dpc,10    jrst    .-1         ;wait for done    hrli    c,-1000     ;word count of 512 (4 sectors worth)    coni    dpc,a       ;get controller status    tlne    a,20        ;18 or 22 bit mode?    lsh     c,4         ;move count to 22 bit position    hrri    c,ldaddr-1  ;insert address to make iowd    movem   c,20        ;put iowd at icwa address of 20    setzm   21          ;end cwa chain    movei   e,40020     ;command read(0) cylinder(0) surface(0) sector(4) icwa(20)    or      e,b         ;insert unit    datao   dpc,e       ;execute    consz   dpc,20    jrst    .-1         ;wait for busy clear    conso   dpc,10    jrst    .-1         ;wait for done    move    a,ldaddr    jumpe   a,getcmd    ;nothing read so abort    movei   b,boomsg    pushj   p,print     ;print boot message    jrst    ldaddr      ;start loaded codemtaboo:    lsh     b,17        ;move unit to bit 20    ori     b,060600    ;tape base command - noop, odd parity, coredump    cono    tmc,0(b)    ;do noop to select device    consz   tms,100000  ;check if at load point    jrst    mtread      ;skip rewind if at load point    cono    tmc,1000(b) ;do start rewind    conso   tms,100     ;job done?    jrst    .-1         ;nope    cono    tmc,0(b)    ;do noop to re-select device    conso   tms,100     ;job done?    jrst    .-1         ;nopemtread:    hrli    c,-10000    ;maximum record word count    conso   tms,400     ;controller in 18 or 22 bit mode?    lsh     c,4         ;move count to 22 bit position    hrri    c,buffer-1  ;insert buffer address to make iowd    movem   c,20        ;put iowd at icwa address of 20    setzm   21          ;end cwa chain    movei   d,20        ;pointer to icwa    datao   tms,d       ;tell data channel where icwa is    movei   a,0    movem   a,buffer    ;zero first word of buffer    cono    tmc,12000(b);do read multi-record    conso   tms,100     ;job done?    jrst    .-1         ;nope    move    c,buffer    ;get first word of record (length + address)    jumpe   c,getcmd    ;nothing read so abort    hlre    d,c         ;get negative length (eg -1000)    movn    e,d         ;make positive    hrrz    d,c         ;get dest address - 1    add     e,d         ;get final destination address    addi    d,1         ;initial destination address    move    f,d         ;keep a copy for checks    hrli    f,buffer+1  ;insert source address    blt     f,@e        ;relocate boot code to new location    hrrz    c,@e        ;get new pc    camge   c,d         ;check pc start range    jrst    getcmd      ;abort    camle   c,e         ;check pc end range    jrst    getcmd      ;abort    jrst    @c          ;start magtape boot routinebanner: asciz 'Paul Nankervis - paulnank@hotmail.com'prompt: asciz 'Boot> 'hlpmsg: ascii 'Commands are BOOT, HELPBoot devices are DPA, MTAeg. Boot> BOOT DPA0'eol:    asciz ''del:    byte (7) 10,40,10,0unkmsg: asciz 'Valid commands are BOOT, HELP'badboo: asciz 'Valid boot devices are DPA, MTA eg dpa0'boomsg: asciz 'Press RETURN to continue loading BOOTS...'cmdboo: asciz 'BOOT'cmdhlp: asciz 'HELP'cmdtbl: point 7,cmdhlp        point 7,cmdboo        0cmdjmp: help        bootdevdpa: asciz 'DPA'devmta: asciz 'MTA'devtbl: point 7,devdpa        point 7,devmta        0boojmp: dpaboo        mtaboostack:    end start